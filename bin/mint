#!/usr/bin/env ruby
# A script for harnessing Mint at the commandline
# Usage: mint [options] files

require 'mint'
require 'shellwords'

# Parse commandline arguments

argv, commandline_options, help = 
  Mint::CommandLine.parse(ARGV).values_at(:argv, :options, :help)

# Minimalist implementation that I want to move to, but
# will have to refactor commandline.rb code and tests
#
# first = argv.first.downcase.to_sym
# commands = [ :install, :edit, :set, :config ]
# command = commands.include?(first) ? command : :mint

# Mint::CommandLine.send(command, commandline_options)

case argv.shift.downcase.to_sym
when :publish
  # Aruba chokes here, so we use this hack to convince Mint we're
  # not in a pipeline
  files = 
    if $stdin.tty? || ENV["MINT_NO_PIPE"]
      argv
    else
      $stdin.each_line.reduce [] do |list, line|
        list.concat(Shellwords.split(line))
      end
    end
  Mint::CommandLine.publish!(files, commandline_options)
when :help
  Mint::CommandLine.help(help)
when :install
  Mint::CommandLine.install(argv.shift, commandline_options)
when :uninstall
  # TODO: Clean up syntax for this to match install syntax
  # Right now it's `mint install file.scss -t pro` vs. `mint uninstall pro`
  Mint::CommandLine.uninstall(argv.shift, commandline_options)
when :templates
  Mint::CommandLine.templates(argv.shift, commandline_options)
when :edit
  Mint::CommandLine.edit(argv.shift, commandline_options)
when :set
  Mint::CommandLine.set(argv.shift, argv.shift, commandline_options)
when :config
  Mint::CommandLine.config
else
  # If no commands were found, search the PATH for commands prefixed
  # with mint-. If no matching executables are found, we know we've
  # been passed a set of documents, so parse the commandline options, 
  # merge them with the config options, and start minting the 
  # document list.
  
  begin
    system "mint-#{argv.first} #{argv[1..-1].join ' '}"
  rescue
    Mint::CommandLine.help(help)
  end
end
