#!/usr/bin/env ruby
# A script for harnessing Mint at the commandline

require 'pathname'
require 'optparse'
require 'yaml'
require 'mint'

module Mint
  # A map of all options that OptParse will accept from the commandline.
  # All other arguments are taken to be filenames.
  def self.options
    {
      # These options take parameters
      template: ['t', 'template', true, 'Specify the template (layout + style).'],
      layout: ['l', 'layout', true, 'Specify only the layout.'],
      style: ['s', 'style', true, 'Specify only the style.'],
      root: ['w', 'root', true, 'Specify a root outside the current directory.'],
      destination: ['d', 'destination', true, 
        'Specify a destination directory, relative to the root.'],
      style_destination: ['n', 'style-destination', true, 
        'Specify a destination directory for stylesheets, or nil to link in place'],

      # These options do not take parameters
      global: ['G', 'global', false, 'Specify config changes on a global level.'],
      user: ['U', 'user', false, 'Specify config changes on a user-wide level.'],
      local: ['L', 'local', false, 'Specify config changes on a project-specific level.'],
      force: ['f', 'force', false, 'Force file overwrite without prompt.'],
      verbose: ['v', 'verbose', false, 'Verbose output.'],
      simulation: ['s', 'simulation', false, 'Simulate transformation without actually creating files.']
    }
  end

  module CommandLine
    def self.config_options
      config_filename = Pathname.new(Mint.files[:config])      

      # Merge config options from all config files on the Mint path,
      # where more local options take precedence over more global
      # options
      Mint.path.map {|p| p + config_filename }.
        select(&:exist?).
        map {|p| YAML.load_file p }.
        reverse.
        reduce(Hash.new) {|r,p| r.merge p }
    end

    def self.full_options_with(commandline_options)
      config_options.merge commandline_options
    end

    def self.write_config(opts, scope=:local)
      config_directory = Mint.path_for_scope scope
      Helpers.ensure_directory config_directory
      Helpers.update_yaml(opts, config_directory + Mint.files[:config])
    end
    
    def self.edit(name, layout_or_style=:layout)
      file = Mint.lookup_template name, layout_or_style
      
      editor = ENV['EDITOR'] || 'vim'
      system "#{editor} #{file}"
    end

    def self.set(key, value, scope=:local)
      write_config({ key => value }, scope)
    end

    def self.config
      puts YAML.dump(config_options)
    end
    
    # Renders and writes to file all resources described by a document.
    # Specifically: it renders itself (inside of its own layout) and then
    # renders its style. This method will overwrite any existing content
    # in a document's destination files. The `render_style` option
    # provides an easy way to stop Mint from rendering a style, even
    # if the document's style is not nil.
    def self.mint(files, commandline_options)
      documents = []
      options = Mint::CommandLine.full_options_with commandline_options
      
      root = options[:root] || Dir.getwd

      # Eventually render_style should be replaced with file change detection
      render_style = true
      files.each do |file|
        Document.new(file, options).mint(root, render_style)
        render_style = false
      end
    end
  end
end

# Parse options from the commandline
commandline_options = {}
optparse = OptionParser.new do |opts|
  opts.banner = 'Usage: mint [command] files [options]'

  Mint.options.each do |k,v|
    has_param = v[2]

    v[0] = "-#{v[0]}"
    v[1] = "--#{v[1]}"

    if has_param
      v[1] << " PARAM"
      opts.on v[0], v[1], v[3] do |p|
        commandline_options[k] = p
      end
    else
      opts.on v[0], v[1], v[3] do
        commandline_options[k] = true
      end
    end
  end
end
optparse.parse!

case ARGV.first.downcase.to_sym

# If we get the edit command, will retrieve appropriate file
# (probably a Mint template) and shell out that file to
# the user's favorite editor. Otherwise ...
when :edit
  layout = commandline_options[:layout]
  style  = commandline_options[:style]

  if layout and not style
    Mint::CommandLine.edit layout, :layout
  elsif style
    Mint::CommandLine.edit style, :style
  else
    puts optparse.help
  end

# ... if we get the set command, we will try to set
# a config option (at the specified scope) per the user's command. Else ...
when :set
  # Determine scope, using local as the default
  commandline_options[:local] = true
  scope = [:global, :user, :local].
    select {|e| commandline_options[e] }.
    first

  Mint::CommandLine.set ARGV.shift, ARGV.shift, scope

# ... if we get the config command, display all active configurations,
# where local configurations override global ones
when :config
  Mint::CommandLine.config

# ... we know we've been passed a set of documents, so parse the
# commandline options, merge them with the config options, and
# start minting the document list.
else
  # The Mint library can't parse these options
  commandline_options.delete :verbose
  commandline_options.delete :simulation

  Mint::CommandLine.mint ARGV, commandline_options
end
