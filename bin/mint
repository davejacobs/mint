#!/usr/bin/env ruby
# A script for harnessing Mint at the commandline

require 'pathname'

$:.unshift Pathname.new(__FILE__).realpath.dirname + '..' + 'lib'

require 'optparse'
require 'yaml'
require 'rubygems'
require 'mint'

module Mint
  def self.options
    {
      :template     
                  => [ 't', 'template', true, 'Specify the template (layout + style).' ],
      :layout     => [ 'l', 'layout', true, 'Specify only the layout.' ],
      :style      => [ 's', 'style', true, 'Specify only the style.' ],
      :copy_style => [ 'c', 'copy-style', false, 'Copy the style to your current directory.' ],
      :root       => [ 'w', 'root', true, 'Specify a root outside the current directory.' ],
      :destination
                  => [ 'd', 'destination', true, 'Specify a destination directory, 
                       relative to the root.' ],
      :style_destination 
                  => [ 'n', 'style-destination', true, 'Specify a destination 
                       subdirectory for stylesheets, relative to the document 
                       destination directory.' ],
      :global     => [ 'G', 'global', false, 'Specify config changes on a global level.' ],
      :user       => [ 'U', 'user', false, 'Specify config changes on a user-wide level.' ],
      :local      => [ 'L', 'local', false, 'Specify config changes on a project-specific level.' ],
      :force      => [ 'f', 'force', false, 'Force file overwrite without prompt.' ],
      :verbose    => [ 'v', 'verbose', false, 'Verbose output.' ],
      :simulation => [ 's', 'simulation', false, 'Simulate transformation without 
                       actually creating files.' ]
    }
  end

  module CommandLine
    def self.config_options
      config_filename = Pathname.new(Mint.files[:config])      
      Mint.path.map {|p| p + config_filename }.
        select(&:exist?).
        inject(Array.new) {|res, p| res + [YAML.parse_file p] }.
        reverse.
        inject(Hash.new) {|res, p| res.merge p }
    end

    def self.full_options_with(commandline_options)
      config_options.merge commandline_options
    end
    
    def self.edit(name, layout_or_style=:layout)
      file = Mint.lookup_template(name, layout_or_style)
      
      editor = ENV['EDITOR'] || 'vim'
      system "#{editor} #{file}"
    end

    def self.set(name, property, scope=:local)
      puts "I haven't yet implemented the mint set function"
    end

    def self.config
      puts "I haven't yet implemented the mint config function"
    end
    
    # Renders and writes to file all resources described by a document.
    # Specifically: it renders itself (inside of its own layout) and then
    # renders its style. This method will overwrite any existing content
    # in a document's destination files. The `render_style` option
    # provides an easy way to stop Mint from rendering a style, even
    # if the document's style is not nil.
    def self.mint(files, commandline_options)
      documents = []
      options = Mint::CommandLine.full_options_with(commandline_options)
      
      root = options[:root] || Dir.getwd

      # Nullify the style destination (meaning the style will render
      # to the style's own centralized directory) unless the user
      # has specified that we're copying the style to his directory.
      (options[:style_destination] = nil) unless options[:copy_style]

      render_style = true
      files.each do |file|
        Document.new(file, options).mint(root, render_style)
        render_style = false
      end
    end
  end
end

# Parse options from the commandline
commandline_options = {}
optparse = OptionParser.new do |opts|
  opts.banner = 'Usage: mint [command] files [options]'

  Mint.options.each do |k,v|
    has_param = v[2]

    v[0] = "-#{v[0]}"
    v[1] = "--#{v[1]}"

    if has_param
      v[1] << " PARAM"
      opts.on v[0], v[1], v[3] do |p|
        commandline_options[k] = p
      end
    else
      opts.on v[0], v[1], v[3] do
        commandline_options[k] = true
      end
    end
  end
end
optparse.parse!

case ARGV.shift.downcase.to_sym
when :edit
  # If we get the "edit" command, will retrieve appropriate file
  # (probably a Mint template) and shell out that file to
  # the user's favorite editor. Otherwise ...
  
  if commandline_options.include? :layout and
      commandline_options.include? :style
    puts optparse.help
  
  elsif layout = commandline_options[:layout]
    Mint::CommandLine.edit(layout, :layout)
  
  elsif style = commandline_options[:style]
    Mint::CommandLine.edit(style, :style)
  
  else
    puts optparse.help
  end
 
when :set
  # ... if we get the set command, we will try to set
  # a config option (at the specified scope) per the user's command. Else ...

  # This command isn't working yet. I need to fix this and then the
  # README. I'm trying to decide between two different syntaxes:
  #
  # This only allows for one key/value to be set at a time, like in git
  #
  #     mint set --global key value
  #
  # This is more confusing, because `global` looks like a command:
  #
  #     mint set global --key=value --second-key=second-value

  scope = ARGV.shift
  key = ARGV.shift
  value = ARGV.shift

  Mint::CommandLine.set key, value, scope.to_sym
  
when :config
  Mint::CommandLine.config

else
  # ... we know we've been passed a set of documents, so parse the
  # commandline options, merge them with the config options, and
  # start minting the document list.
  
  commandline_options.delete(:verbose)
  commandline_options.delete(:simulation)
  
  Mint::CommandLine.mint ARGV, commandline_options
end
