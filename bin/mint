#!/usr/bin/env ruby
# A script for harnessing Mint at the commandline

$:.unshift File.join(File.dirname(__FILE__), '..', 'lib')

require 'optparse'
require 'yaml'
require 'rubygems'
require 'mint'

module Mint
  def self.options
    options = {
      :template          => ['t', 'template', true, 'Description'],
      :layout            => ['l', 'layout', true, 'Description'],
      :style             => ['s', 'style', true, 'Description', 
                              'Description'],
      :destination       => ['d', 'destination', true, 'Description'],
      :style_destination => ['n', 'style-destination', true, 
                              'Description'],
      :global            => ['G', 'global', false, 'Description'],
      :user              => ['U', 'user', false, 'Description'],
      :local             => ['L', 'local', false, 'Description'],
      :verbose           => ['v', 'verbose', false, 'Description'],
      :simulation        => ['s', 'simulation', false, 'Description']
    }
  end

  module CommandLine
    def self.config_options
      config_filename = Pathname.new(Mint.files[:config])      
      
      ordered_options = []
      
      path = Mint.path
      path.each_index do |i|
        if (config_file = path[i] + config_filename).exist?
          ordered_options << YAML.parse_file(config_file)
        end
      end
      
      ordered_options.reverse.inject(Hash.new) { |mem, o| mem.merge(o) }
    end

    def self.full_options_with(commandline_options)
      config_options.merge commandline_options
    end
    
    def self.edit(name, layout_or_style=:layout)
      file = Mint.lookup_template(name, layout_or_style)
      
      editor = ENV['EDITOR'] || 'vim'
      system "#{editor} #{file}"
    end
    
    # Renders and writes to file all resources described by a document.
    # Specifically: it renders itself (inside of its own layout) and then
    # renders its style. This method will overwrite any existing content
    # in a document's destination files. The `render_style` option
    # provides an easy way to stop Mint from rendering a style, even
    # if the document's style is not nil.
    def self.mint(files, commandline_options)
      documents = []
      options = Mint::CommandLine.full_options_with(commandline_options)
     
      style_template_name = options[:style]
      style_dest = options[:style_destination]

      options[:style] = Style.new(style_template_name, :destination => style_dest)

      render_style = true
      files.each do |file|
        Document.new(file, options).mint(Dir.getwd, render_style)
        style_rendered = false
      end
    end
  end
end

commandline_options = {}
optparse = OptionParser.new do |opts|
  opts.banner = 'Usage: mint source [destination] [options]'

  Mint.options.each do |k,v|
    has_param = v[2]

    v[0] = "-#{v[0]}"
    v[1] = "--#{v[1]}"

    if has_param
      v[1] << " PARAM"
      opts.on v[0], v[1], v[3] do |p|
        commandline_options[k] = p
      end
    else
      opts.on v[0], v[1], v[3] do
        commandline_options[k] = true
      end
    end
  end
end
optparse.parse!

if ARGV[0] == 'edit'
  # If we get the "edit" command, will retrieve appropriate file
  # (probably a Mint template) and shell out that file to
  # the user's favorite editor. Otherwise ...
  
  if commandline_options.include? :layout and
      commandline_options.include? :style
    puts optparse.help
  
  elsif layout = commandline_options[:layout]
    Mint::CommandLine.edit(layout, :layout)
  
  elsif style = commandline_options[:style]
    Mint::CommandLine.edit(style, :style)
  
  else
    puts optparse.help
  end
  
elsif ARGV[0] == 'set'
  # ... if we get the set command, we will try to set
  # a config option (at the specified scope) per the user's command. Else ...
  
else
  # ... we know we've been passed a set of documents, so parse the
  # commandline options, merge them with the config options, and
  # start minting the document list.
  
  puts "commandline options = #{commandline_options.inspect}"
  
  commandline_options.delete(:verbose)
  commandline_options.delete(:simulation)
  
  Mint::CommandLine.mint ARGV, commandline_options
end
