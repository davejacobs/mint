#!/usr/bin/env ruby
# A script for harnessing Mint at the commandline

require 'pathname'
require 'optparse'
require 'yaml'
require 'mint'

module Mint
  module CommandLine
    # A map of all options that OptParse will accept from the commandline.
    # All other arguments are taken to be filenames.
    def self.options
      # Options file, relative to this one
      options_file = '../../config/options.yaml'
      YAML.load_file File.expand_path(options_file, __FILE__)
    end

    def self.config_options
      config_filename = Pathname.new(Mint.files[:config])      

      # Merge config options from all config files on the Mint path,
      # where more local options take precedence over more global
      # options
      Mint.path.map {|p| p + config_filename }.
        select(&:exist?).
        map {|p| YAML.load_file p }.
        reverse.
        reduce(Mint.default_options) {|r,p| r.merge p }
    end

    def self.full_options_with(commandline_options)
      config_options.merge commandline_options
    end

    # def self.install(file, scope=:local)
    #   directory = path_for_scope(scope)
    #   FileUtils.copy file, directory
    # end

    def self.edit(name, layout_or_style=:layout)
      file = Mint.lookup_template name, layout_or_style
      
      editor = ENV['EDITOR'] || 'vim'
      system "#{editor} #{file}"
    end

    def self.write_config(opts, scope=:local)
      config_directory = Mint.path_for_scope scope
      Helpers.ensure_directory config_directory
      Helpers.update_yaml(opts, config_directory + Mint.files[:config])
    end
 
    def self.set(key, value, scope=:local)
      write_config({ key => value }, scope)
    end

    def self.config
      puts YAML.dump(config_options)
    end
    
    # Renders and writes to file all resources described by a document.
    # Specifically: it renders itself (inside of its own layout) and then
    # renders its style. This method will overwrite any existing content
    # in a document's destination files. The `render_style` option
    # provides an easy way to stop Mint from rendering a style, even
    # if the document's style is not nil.
    def self.mint(files, commandline_options)
      documents = []
      options = Mint::CommandLine.full_options_with commandline_options
      
      root = options[:root] || Dir.getwd

      # Eventually render_style should be replaced with file change detection
      render_style = true
      files.each do |file|
        Document.new(file, options).mint(root, render_style)
        render_style = false
      end
    end
  end
end

# Parse options from the commandline
commandline_options = {}
optparse = OptionParser.new do |opts|
  opts.banner = 'Usage: mint [command] files [options]'

  Mint::CommandLine.options.each do |k,v|
    has_param = v['parameter']

    v['short'] = "-#{v['short']}"
    v['long'] = "--#{v['long']}"

    if has_param
      v['long'] << " PARAM"
      opts.on v['short'], v['long'], v['description'] do |p|
        commandline_options[k.to_sym] = p
      end
    else
      opts.on v['short'], v['long'], v['description'] do
        commandline_options[k] = true
      end
    end
  end
end
optparse.parse!

case ARGV.first.downcase.to_sym

when :help
  puts optparse.help

# ... if we get the install command, install the listed file to the
# scope listed, using local as the default scope
when :install
  commandline_options[:local] = true
  scope = [:global, :user, :local].
    select {|e| commandline_options[e] }.
    first

  Mint::CommandLine.install ARGV.shift, scope

# If we get the edit command, will retrieve appropriate file
# (probably a Mint template) and shell out that file to
# the user's favorite editor. Otherwise ...
when :edit
  layout = commandline_options[:layout]
  style  = commandline_options[:style]

  if layout and not style
    Mint::CommandLine.edit layout, :layout
  elsif style
    Mint::CommandLine.edit style, :style
  else
    puts optparse.help
  end

# ... if we get the set command, we will try to set
# a config option (at the specified scope) per the user's command. Else ...
when :set
  # Determine scope, using local as the default
  commandline_options[:local] = true
  scope = [:global, :user, :local].
    select {|e| commandline_options[e] }.
    first

  Mint::CommandLine.set ARGV.shift, ARGV.shift, scope

# ... if we get the config command, display all active configurations,
# where local configurations override global ones
when :config
  Mint::CommandLine.config

# ... we know we've been passed a set of documents, so parse the
# commandline options, merge them with the config options, and
# start minting the document list.
else
  # The Mint library can't parse these options
  commandline_options.delete :verbose
  commandline_options.delete :simulation

  Mint::CommandLine.mint ARGV, commandline_options
end
