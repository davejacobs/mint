#!/usr/bin/env ruby
# A script for harnessing Mint at the commandline
# Usage: mint [options] files

require 'mint'

# Parse options from the commandline
commandline_options = {}
process_opts = lambda {|k,v| commandline_options[k] = v }
Mint::CommandLine.parser(&process_opts).parse!

# Minimalist implementation that I want to move to, but
# will have to refactor commandline.rb code and tests
#
# first = ARGV.first.downcase.to_sym
# commands = [ :install, :edit, :set, :config ]
# command = commands.include?(first) ? command : :mint

# Mint::CommandLine.send command, commandline_options

case ARGV.first.downcase.to_sym
when :help
  Mint::CommandLine.help(optparse.help)

when :install
  commandline_options[:local] = true
  scope = [:global, :user, :local].
    select {|e| commandline_options[e] }.
    first

  Mint::CommandLine.install ARGV.shift, scope

when :edit
  layout = commandline_options[:layout]
  style = commandline_options[:style]

  if layout and not style
    Mint::CommandLine.edit layout, :layout
  elsif style
    Mint::CommandLine.edit style, :style
  else
    puts optparse.help
  end

when :set
  # Determine scope, using local as the default
  commandline_options[:local] = true
  scope = [:global, :user, :local].
    select {|e| commandline_options[e] }.
    first

  Mint::CommandLine.set ARGV.shift, ARGV.shift, scope

when :config
  Mint::CommandLine.config

else
  # If no commands were found, search the PATH for commands prefixed
  # with mint-. If no matching executables are found, we know we've
  # been passed a set of documents, so parse the commandline options, 
  # merge them with the config options, and start minting the 
  # document list.
  
  # begin
  #   system "mint-#{ARGV.first}"

  # rescue
    # The Mint library can't parse these options
    commandline_options.delete :verbose
    commandline_options.delete :simulation

    Mint::CommandLine.mint ARGV, commandline_options
  # end
end
