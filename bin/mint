#!/usr/bin/env ruby
# A script for harnessing Mint at the commandline
# Usage: mint [options] files

require 'mint'

# Parse options from the commandline
commandline_options = {}
process_opts = lambda {|k,v| commandline_options[k] = v }
parser = Mint::CommandLine.parser(&process_opts)
parser.parse!

# Minimalist implementation that I want to move to, but
# will have to refactor commandline.rb code and tests
#
# first = ARGV.first.downcase.to_sym
# commands = [ :install, :edit, :set, :config ]
# command = commands.include?(first) ? command : :mint

# Mint::CommandLine.send(command, commandline_options)

case ARGV.shift.downcase.to_sym
when :publish
  commandline_options.delete :verbose
  commandline_options.delete :simulation
  Mint::CommandLine.publish!(ARGV, commandline_options)
when :help
  Mint::CommandLine.help(parser.help)
when :install
  Mint::CommandLine.install(ARGV.shift, commandline_options)
when :uninstall
  # TODO: Clean up syntax for this to match install syntax
  # Right now it's `mint install file.scss -t pro` vs. `mint uninstall pro`
  Mint::CommandLine.uninstall(ARGV.shift, commandline_options)
when :templates
  Mint::CommandLine.templates
when :edit
  Mint::CommandLine.edit(ARGV.shift, commandline_options)
when :set
  Mint::CommandLine.set(ARGV.shift, ARGV.shift, commandline_options)
when :config
  Mint::CommandLine.config
else
  # If no commands were found, search the PATH for commands prefixed
  # with mint-. If no matching executables are found, we know we've
  # been passed a set of documents, so parse the commandline options, 
  # merge them with the config options, and start minting the 
  # document list.
  
  begin
    system "mint-#{ARGV.first} #{ARGV[1..-1].join ' '}"
  rescue
    Mint::CommandLine.help(parser.help)
  end
end
